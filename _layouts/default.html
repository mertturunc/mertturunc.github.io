{% include language-utils.html %}
<!doctype html>
<html lang="{{ current_lang }}" prefix="og: http://ogp.me/ns#" xmlns:og="http://opengraphprotocol.org/schema/">
<head>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8"/>
  {% if page.class == "page_wide" %}
    <meta name="viewport" content="width=900" />
  {% else %}
    <meta name="viewport" content="width=640" />
  {% endif %}
  <meta name="theme-color" content="hsl(199, 39%, 39%)">
  <link href="/i/favicon.png" rel="icon" sizes="32x32">

  <!-- Apply theme immediately to prevent flash -->
  <script>
    (function() {
      const savedTheme = localStorage.getItem('theme') || 'dark';
      if (savedTheme === 'dark') {
        document.documentElement.setAttribute('data-theme', 'dark');
      }
    })();
  </script>

  <link href="https://fonts.googleapis.com/css2?family=Archivo+Black&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <link href='/style.css?v=20201203' rel='stylesheet' type='text/css' />
  {% include syntax-highlighting.html %}
  <title>{{ page.title }} @ {{ t.site_title }}</title>

  <link href="/blog/atom.xml" rel="alternate" title="atr0p's blog" type="application/atom+xml" />

  <meta name="author" content="Mert Turun√ß" />
  
  <!-- Open Graph meta tags for LinkedIn and other social media -->
  <meta property="og:type" content="{% if page.categories contains 'blog' %}article{% else %}website{% endif %}" />
  <meta property="og:title" content="{{ page.title }}" />
  <meta property="og:description" content="{% if page.summary %}{{ page.summary }}{% elsif page.description %}{{ page.description }}{% else %}{{ t.site_description }}{% endif %}" />
  <meta property="og:url" content="{{ site.url }}{{ page.url }}" />
  <meta property="og:site_name" content="{{ t.site_title }}" />
  {% if page.header %}
    {% if page.header contains '://' %}
      <meta property="og:image" content="{{ page.header }}" />
    {% else %}
      <meta property="og:image" content="{{ site.url }}{{ page.header }}" />
    {% endif %}
  {% else %}
    {% comment %} Check for generated placeholder {% endcomment %}
    {% assign safe_title = page.title | replace: ' ', '-' | replace: ':', '' | replace: '"', '' | replace: "'", '' | downcase %}
    {% assign date_str = page.date | date: "%Y-%m-%d" %}
    {% assign placeholder_filename = date_str | append: '-' | append: safe_title | append: '-placeholder.svg' %}
    {% assign placeholder_path = '/placeholders/' | append: placeholder_filename %}
    <meta property="og:image" content="{{ site.url }}{{ placeholder_path }}" />
  {% endif %}
  <meta property="og:image:width" content="1200" />
  <meta property="og:image:height" content="630" />
  <meta property="og:image:type" content="image/svg+xml" />
  
  {% if page.categories contains 'blog' %}
    <meta property="article:published_time" content="{{ page.date | date: '%Y-%m-%d' }}" />
    <meta property="article:author" content="Mert Turun√ß" />
  {% endif %}

  <!-- Twitter Card meta tags -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:site" content="@GeoTurunc" />
  <meta name="twitter:creator" content="@GeoTurunc" />
  <meta name="twitter:title" content="{{ page.title }}" />
  <meta name="twitter:description" content="{% if page.summary %}{{ page.summary }}{% elsif page.description %}{{ page.description }}{% else %}{{ t.site_description }}{% endif %}" />
  {% if page.header %}
    {% if page.header contains '://' %}
      <meta name="twitter:image" content="{{ page.header }}" />
    {% else %}
      <meta name="twitter:image" content="{{ site.url }}{{ page.header }}" />
    {% endif %}
  {% else %}
    {% comment %} Use the same placeholder logic for Twitter {% endcomment %}
    {% assign safe_title = page.title | replace: ' ', '-' | replace: ':', '' | replace: '"', '' | replace: "'", '' | downcase %}
    {% assign date_str = page.date | date: "%Y-%m-%d" %}
    {% assign placeholder_filename = date_str | append: '-' | append: safe_title | append: '-placeholder.svg' %}
    {% assign placeholder_path = '/placeholders/' | append: placeholder_filename %}
    <meta name="twitter:image" content="{{ site.url }}{{ placeholder_path }}" />
  {% endif %}

  {% comment %} Add alternate language links {% endcomment %}
  {% if current_lang == 'tr' %}
    <link rel="alternate" hreflang="en" href="https://mertturunc.github.io/en{{ page.url }}" />
    <link rel="alternate" hreflang="tr" href="https://mertturunc.github.io{{ page.url }}" />
  {% else %}
    <link rel="alternate" hreflang="tr" href="https://mertturunc.github.io{{ page.url | remove: '/en' }}" />
    <link rel="alternate" hreflang="en" href="https://mertturunc.github.io{{ page.url }}" />
  {% endif %}
</head>
<body>
<!-- Top controls -->
<div class="top-controls">
  <!-- Theme Toggle Button -->
  <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
    <span id="theme-icon">‚òÄÔ∏è</span>
  </button>
  
  <!-- Language Switcher -->
  {% include language-switcher.html %}
</div>

<div class="page {{ page.class }}">

{{ content }}

<div class="preload"></div>

<script>
// Theme switching functionality
(function() {
  const themeToggle = document.getElementById('theme-toggle');
  const themeIcon = document.getElementById('theme-icon');
  const html = document.documentElement;
  
  // Get current theme state
  const currentTheme = localStorage.getItem('theme') || 'dark';
  
  // Update icon based on current theme
  function updateIcon(theme) {
    if (theme === 'dark') {
      themeIcon.textContent = '‚òÄÔ∏è';
    } else {
      themeIcon.textContent = 'üåô';
    }
  }
  
  // Initialize icon
  updateIcon(currentTheme);
  
  // Theme toggle click handler
  themeToggle.addEventListener('click', function() {
    const isCurrentlyDark = html.hasAttribute('data-theme');
    const newTheme = isCurrentlyDark ? 'light' : 'dark';
    
    // Apply new theme
    if (newTheme === 'dark') {
      html.setAttribute('data-theme', 'dark');
    } else {
      html.removeAttribute('data-theme');
    }
    
    // Update icon
    updateIcon(newTheme);
    
    // Save preference
    localStorage.setItem('theme', newTheme);
  });
})();

// Header anchor links functionality
(function() {
  // Function to create a URL-friendly slug from text
  function createSlug(text) {
    return text
      .toLowerCase()
      .replace(/[^\w\s-]/g, '') // Remove special characters
      .replace(/\s+/g, '-')     // Replace spaces with hyphens
      .replace(/-+/g, '-')      // Replace multiple hyphens with single
      .trim();
  }

  // Add anchor links to headers
  document.addEventListener('DOMContentLoaded', function() {
    const headers = document.querySelectorAll('h1:not(.r-title), h2, h3, h4, h5, h6');
    
    headers.forEach(function(header) {
      // Create slug from header text
      const slug = createSlug(header.textContent);
      
      // Set the id if it doesn't exist
      if (!header.id) {
        header.id = slug;
      }
      
      // Add click handler
      header.addEventListener('click', function() {
        // Update URL with anchor
        const newUrl = window.location.pathname + window.location.search + '#' + header.id;
        window.history.pushState(null, null, newUrl);
        
        // Optional: scroll to header smoothly
        header.scrollIntoView({ behavior: 'smooth' });
        
        // Copy link to clipboard
        navigator.clipboard.writeText(window.location.href).then(function() {
          // Show a brief visual feedback
          const originalColor = header.style.color;
          header.style.color = 'var(--accent-color)';
          setTimeout(function() {
            header.style.color = originalColor;
          }, 200);
        }).catch(function() {
          // Fallback if clipboard API is not available
          console.log('Link: ' + window.location.href);
        });
      });
    });
  });
})();

// Copy button functionality for code blocks
(function() {
  // Get translation strings (will be populated by Jekyll)
  const translations = {
    copy: '{{ t.copy_button.copy }}',
    copied: '{{ t.copy_button.copied }}',
    error: '{{ t.copy_button.error }}'
  };

  function createCopyButton() {
    const button = document.createElement('button');
    button.className = 'copy-button';
    button.innerHTML = 'üìã ' + translations.copy;
    button.setAttribute('aria-label', 'Copy code to clipboard');
    return button;
  }

  function copyCodeToClipboard(text, button) {
    if (navigator.clipboard && window.isSecureContext) {
      // Use modern clipboard API
      navigator.clipboard.writeText(text).then(function() {
        if (button) {
          showCopySuccess(button);
        }
      }).catch(function() {
        fallbackCopyCodeToClipboard(text, button);
      });
    } else {
      // Fallback for older browsers or non-secure contexts
      fallbackCopyCodeToClipboard(text, button);
    }
  }

  function fallbackCopyCodeToClipboard(text, button) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
      document.execCommand('copy');
      if (button) {
        showCopySuccess(button);
      }
    } catch (err) {
      console.error('Failed to copy text: ', err);
      if (button) {
        showCopyError(button);
      }
    } finally {
      document.body.removeChild(textArea);
    }
  }

  function showCopySuccess(button) {
    if (button) {
      const originalText = button.innerHTML;
      button.innerHTML = '‚úÖ ' + translations.copied;
      button.classList.add('copied');
      
      setTimeout(function() {
        button.innerHTML = originalText;
        button.classList.remove('copied');
      }, 2000);
    }
  }

  function showCopyError(button) {
    if (button) {
      const originalText = button.innerHTML;
      button.innerHTML = '‚ùå ' + translations.error;
      
      setTimeout(function() {
        button.innerHTML = originalText;
      }, 2000);
    }
  }

  function addCopyButtonToCodeBlock(codeBlock) {
    // Skip if button already exists (more robust check)
    if (codeBlock.querySelector('.copy-button') || codeBlock.hasAttribute('data-copy-button-added')) {
      return;
    }
    
    // Skip inline code elements - only add copy buttons to block-level code
    if (codeBlock.tagName === 'CODE' && !codeBlock.closest('pre') && !codeBlock.closest('.highlight')) {
      return;
    }
    
    // Mark this element as processed to prevent duplicate processing
    codeBlock.setAttribute('data-copy-button-added', 'true');

    const button = createCopyButton();
    
    button.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      
      // Get the code content - look for code element in various structures
      let codeElement = codeBlock.querySelector('code');
      if (!codeElement) {
        // If no code element, use the pre element or the container itself
        codeElement = codeBlock.querySelector('pre') || codeBlock;
      }
      
      let codeText = codeElement.textContent || codeElement.innerText;
      
      // Clean up the text (remove extra whitespace)
      codeText = codeText.trim();
      
      copyCodeToClipboard(codeText, button);
    });

    // Find the best container for the button (the one with the visual styling)
    let buttonContainer = codeBlock;
    
    // For Rouge blocks, append to the inner .highlight div for proper positioning
    const highlightDiv = codeBlock.querySelector('.highlight');
    if (highlightDiv) {
      buttonContainer = highlightDiv;
    }
    
    buttonContainer.appendChild(button);
  }

  // Clean up any copy buttons that were incorrectly added to inline code
  function cleanupInlineCopyButtons() {
    const inlineCodeElements = document.querySelectorAll('code:not(pre code):not(.highlight code)');
    inlineCodeElements.forEach(function(codeElement) {
      const copyButton = codeElement.querySelector('.copy-button');
      if (copyButton) {
        copyButton.remove();
      }
      codeElement.removeAttribute('data-copy-button-added');
    });
  }

  // Initialize copy buttons when DOM is ready
  function initializeCopyButtons() {
    // First, clean up any incorrectly placed copy buttons
    cleanupInlineCopyButtons();
    
    // Strategy: Only target block-level code elements, not inline code
    
    // For Jekyll/Rouge: target .highlighter-rouge containers that contain pre or .highlight
    const rougeBlocks = document.querySelectorAll('.highlighter-rouge');
    rougeBlocks.forEach(function(block) {
      // Only add copy button if it contains a pre or .highlight element
      if (block.querySelector('pre') || block.querySelector('.highlight')) {
        addCopyButtonToCodeBlock(block);
      }
    });
    
    // For standalone pre elements (not inside any syntax highlighting wrapper)
    const standalonePreBlocks = document.querySelectorAll('pre:not(.highlighter-rouge pre):not(.highlight)');
    standalonePreBlocks.forEach(function(codeBlock) {
      addCopyButtonToCodeBlock(codeBlock);
    });
    
    // Also target .highlight divs directly (for cases where they're not in .highlighter-rouge)
    const highlightBlocks = document.querySelectorAll('.highlight');
    highlightBlocks.forEach(function(block) {
      // Only add if it contains a pre element and isn't already processed
      if (block.querySelector('pre') && !block.closest('.highlighter-rouge')) {
        addCopyButtonToCodeBlock(block);
      }
    });
  }

  // Run on DOM content loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeCopyButtons);
  } else {
    initializeCopyButtons();
  }

  // Also run after a short delay to catch any dynamically added content
  setTimeout(initializeCopyButtons, 100);
})();

// Language chip functionality
(function() {
  function getLanguageFromClass(element) {
    const classes = element.className.split(' ');
    for (let className of classes) {
      // Standard patterns
      if (className.startsWith('language-')) {
        return className.replace('language-', '');
      }
      if (className.startsWith('highlight-')) {
        return className.replace('highlight-', '');
      }
      // Rouge patterns
      if (className.startsWith('highlighter-rouge-')) {
        return className.replace('highlighter-rouge-', '');
      }
      // Direct language names (for Rouge output)
      const knownLanguages = [
        'bash', 'shell', 'sh', 'zsh', 'powershell', 'cmd', 'terminal', 'console',
        'javascript', 'js', 'typescript', 'ts', 'json',
        'html', 'xml', 'css', 'scss', 'sass', 'less',
        'php', 'python', 'ruby', 'java', 'c', 'cpp', 'csharp',
        'sql', 'mysql', 'postgresql', 'sqlite',
        'yaml', 'yml', 'toml', 'ini', 'config',
        'markdown', 'md', 'text', 'txt', 'plain'
      ];
      if (knownLanguages.includes(className.toLowerCase())) {
        return className.toLowerCase();
      }
    }
    return null;
  }

  function mapLanguageToType(language) {
    const langMap = {
      'html': 'html',
      'xml': 'html',
      'css': 'css',
      'scss': 'sass',
      'sass': 'sass',
      'javascript': 'javascript',
      'js': 'javascript',
      'typescript': 'javascript',
      'ts': 'javascript',
      'json': 'json',
      'python': 'python',
      'py': 'python',
      'php': 'php',
      'sql': 'sql',
      'mysql': 'sql',
      'postgresql': 'sql',
      'bash': 'bash',
      'shell': 'bash',
      'sh': 'bash',
      'zsh': 'bash',
      'powershell': 'bash',
      'cmd': 'bash',
      'terminal': 'bash',
      'console': 'bash',
      'text': 'text',
      'txt': 'text',
      'plain': 'text'
    };
    return langMap[language.toLowerCase()] || 'text';
  }

  function fallbackCopyTextToClipboard(text, chip) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
      document.execCommand('copy');
      // Success - show visual feedback on chip with animation
      const originalBackground = chip.style.background;
      const originalColor = chip.style.color;
      const originalTransform = chip.style.transform;
      
      // Animate success state
      chip.style.background = '#28a745';
      chip.style.color = 'white';
      chip.style.transition = 'all 0.2s ease';
      
      // Reset after 2 seconds with smooth transition
      setTimeout(() => {
        chip.style.background = originalBackground;
        chip.style.color = originalColor;
        chip.style.transform = originalTransform;
        chip.style.transition = 'all 0.4s ease-out';
      }, 2000);
    } catch (err) {
      console.error('Failed to copy text: ', err);
      // Error - show visual feedback on chip with animation
      const originalBackground = chip.style.background;
      const originalColor = chip.style.color;
      const originalTransform = chip.style.transform;
      
      // Animate error state
      chip.style.background = '#dc3545';
      chip.style.color = 'white';
      chip.style.transition = 'all 0.2s ease';
      
      // Reset after 2 seconds with smooth transition
      setTimeout(() => {
        chip.style.background = originalBackground;
        chip.style.color = originalColor;
        chip.style.transform = originalTransform;
        chip.style.transition = 'all 0.4s ease-out';
      }, 2000);
    } finally {
      document.body.removeChild(textArea);
    }
  }

  function createLanguageChip(language) {
    const type = mapLanguageToType(language);
    const chip = document.createElement('em');
    chip.className = `codeblock-chip type-${type}`;
    chip.setAttribute('data-lang', language.toUpperCase());
    
    // Add click functionality to directly copy code
    chip.addEventListener('click', function() {
      const codeBlock = this.closest('.content-codeblock');
      if (codeBlock) {
        // Get the code content from the correct structure
        let codeText = '';
        
        // Find the code block that's a sibling of the chip
        const codeBlockElement = this.nextElementSibling;
        
        if (codeBlockElement) {
          // Based on the console logs, the structure is:
          // .highlighter-rouge > .highlight > pre (with the actual code)
          const preElement = codeBlockElement.querySelector('.highlight pre') || 
                            codeBlockElement.querySelector('pre');
          
          if (preElement) {
            codeText = preElement.textContent || preElement.innerText;
          }
        }
        
        // Clean up the text (remove extra whitespace)
        codeText = codeText.trim();
        
        // Copy to clipboard directly using the global copyToClipboard function
        if (navigator.clipboard && window.isSecureContext) {
          // Use modern clipboard API
          navigator.clipboard.writeText(codeText).then(function() {
            // Success - show visual feedback on chip with animation
            const chip = this;
            const originalBackground = chip.style.background;
            const originalColor = chip.style.color;
            const originalTransform = chip.style.transform;
            
            // Animate success state
            chip.style.background = '#28a745';
            chip.style.color = 'white';
            chip.style.transition = 'all 0.2s ease';
            
            // Reset after 2 seconds with smooth transition
            setTimeout(() => {
              chip.style.background = originalBackground;
              chip.style.color = originalColor;
              chip.style.transition = 'all 0.3s ease';
            }, 2000);
          }.bind(this)).catch(function() {
            // Fallback for older browsers or non-secure contexts
            fallbackCopyTextToClipboard(codeText, this);
          }.bind(this));
        } else {
          // Fallback for older browsers or non-secure contexts
          fallbackCopyTextToClipboard(codeText, this);
        }
      }
    });
    
    // Add cursor pointer to indicate it's clickable
    chip.style.cursor = 'pointer';
    
    return chip;
  }

  function wrapCodeBlockWithNewStructure(codeBlock) {
    // Skip if already wrapped
    if (codeBlock.closest('.section-codeblock')) {
      return;
    }

    // Get language from various possible sources
    let language = null;
    const codeElement = codeBlock.querySelector('code');
    const preElement = codeBlock.querySelector('pre') || (codeBlock.tagName === 'PRE' ? codeBlock : null);
    
    // Try to detect language from highlight class or code class
    if (codeElement) {
      language = getLanguageFromClass(codeElement);
    }
    if (!language && preElement) {
      language = getLanguageFromClass(preElement);
    }
    if (!language) {
      language = getLanguageFromClass(codeBlock);
    }
    
    // Check data attributes
    if (!language && codeElement) {
      language = codeElement.dataset.lang || codeElement.dataset.language;
    }
    if (!language && preElement) {
      language = preElement.dataset.lang || preElement.dataset.language;
    }
    if (!language) {
      language = codeBlock.dataset.lang || codeBlock.dataset.language;
    }
    
    // Look for Rouge's data-lang pattern
    const dataLangElement = codeBlock.querySelector('[data-lang]');
    if (!language && dataLangElement) {
      language = dataLangElement.dataset.lang;
    }
    
    // Language detection complete
    if (!language) {
      language = 'text'; // fallback
    }

    const type = mapLanguageToType(language);

    // Create the new structure
    const sectionCodeblock = document.createElement('div');
    sectionCodeblock.className = 'section-codeblock';

    const contentCodeblock = document.createElement('div');
    contentCodeblock.className = 'content-codeblock';
    
    const chip = createLanguageChip(language);

    // Wrap the existing code block
    const parent = codeBlock.parentNode;
    parent.insertBefore(sectionCodeblock, codeBlock);
    sectionCodeblock.appendChild(contentCodeblock);
    
    // Add chip and code block as direct children of content-codeblock
    contentCodeblock.appendChild(chip);
    contentCodeblock.appendChild(codeBlock);
  }

  function initializeLanguageChips() {
    // Target .highlighter-rouge containers
    const rougeBlocks = document.querySelectorAll('.highlighter-rouge');
    rougeBlocks.forEach(function(block) {
      if (block.querySelector('pre') || block.querySelector('.highlight')) {
        wrapCodeBlockWithNewStructure(block);
      }
    });
    
    // Target standalone pre elements
    const standalonePreBlocks = document.querySelectorAll('pre:not(.highlighter-rouge pre):not(.highlight)');
    standalonePreBlocks.forEach(function(codeBlock) {
      wrapCodeBlockWithNewStructure(codeBlock);
    });
    
    // Target .highlight divs directly
    const highlightBlocks = document.querySelectorAll('.highlight');
    highlightBlocks.forEach(function(block) {
      if (block.querySelector('pre') && !block.closest('.highlighter-rouge')) {
        wrapCodeBlockWithNewStructure(block);
      }
    });
  }

  // Run on DOM content loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeLanguageChips);
  } else {
    initializeLanguageChips();
  }

  // Also run after a short delay to catch any dynamically added content
  setTimeout(initializeLanguageChips, 100);
  
  // Additional safety runs
  setTimeout(initializeLanguageChips, 500);
  setTimeout(initializeLanguageChips, 1000);
  
  // Listen for any dynamic content changes
  document.addEventListener('DOMContentLoaded', function() {
    // Run immediately
    initializeLanguageChips();
    
    // Set up a mutation observer to catch dynamically added content
    const observer = new MutationObserver(function(mutations) {
      let shouldReinitialize = false;
      mutations.forEach(function(mutation) {
        if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
          mutation.addedNodes.forEach(function(node) {
            if (node.nodeType === 1) { // Element node
              if (node.querySelector && (node.querySelector('pre') || node.querySelector('.highlight') || node.querySelector('.highlighter-rouge'))) {
                shouldReinitialize = true;
              }
            }
          });
        }
      });
      
      if (shouldReinitialize) {
        setTimeout(initializeLanguageChips, 50);
      }
    });
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  });
})();
</script>

</body>
</html>


